დავალება 1

1) შექმენით ცარიელი ფაილები შემდეგი დასახელებით: 1, 2, … 1000. მათგან გამოიტანეთ ის დასახელებები, სადაც შედის 1) მხოლოდ ორი ციფრი. 2) მხოლოდ ციფრი 9. 3) მხოლოდ სამი ციფრი და თან მათში არ ფიგურირებდეს 1,4 და 7

2) შექმენით დირექტორიები შემდეგი დასახელებით: dir1, dir2, … dir100 და თითოეულ მათგანში შექმენით წინა სავარჯიშოში მოცემული პირობა.

3) შექმენით 4 სიმბოლოიანი (ყველა შესაძლო) დასახელების ფაილები შემდეგი ასო-ნიშნებით: A, \, $ და 4. მათგან გამოიტანეთ ის დასახელებები, სადაც 1) არ შედის $. 2) მესამე პოზიციაზე არის \. 3) არ შედის A.

4) შექმენით სამციფრა (ყველა შესაძლო) დასახელების ფაილები როგორ txt გაფართოებით, ასევე მის გარეშე (გაფართოება დიდი და პატარა ასოების ყველა შესაძლო კომბინაციით)

5) მიმდინარე დირექტორიაში არსებული .txt ფაილების სია ჩაწერეთ files.txt ფაილში და ამავდროულად, ეს სია გამოაჩინეთ მეორე გახსნილ ტერმინალში.

1)
	touch {1..1000}
	ls ??
	ls *[9]*   ან       ls *[9]* | grep -E '^9+$' | paste -s -d" "
	ls [!147][!147][!147]

2)
	mkdir dir{1..100}
	touch ./dir[1..100}/{1..1000}

3)	
	touch {A,\\,\$,4}{A,\\,\$,4}{A,\\,\$,4}{A,\\,\$,4}
	ls [^$][^$][^$][^$]
	ls ??\\?     ან    ls [^\\][^\\]\\[^\\]
	ls [^A][^A][^A][^A]

4)
	touch {100..999}{,.{T,t}{X,x}{T,t}}

5)
	ls *.txt | tee files.txt > /dev/pts/1
	






დავალება 2

1) დააცარიელეთ თქვენს პირად დირექტორიაში არსებული tmp დირექტორია. წაშალეთ დამალული ფაილებიც. (ყურადღება მიაქციეთ იმას, რომ დირექტორიაში არ უნდა შეეხოთ . და .. დასახელების ქვედირექტორიებს).

2) თუ ფაილი foobar არ არსებობს მიმდინარე დირექტორიაში, შექმენით ფაილი toto დასახელებით, თუ კი - ფაილი titi დასახელებით.
ეკრანზე შეცდომის შეტყობინება არ გამოიტანოთ.

3) foobar ფაილის 2-5 სვეტის 5-10 სტრიქონი შეინახეთ ფაილში foobarnew.

4) ვთქვათ გაქვთ სამი ფაილი n1.txt, n2.txt, n3.txt, სადაც თითოეულში ერთ ხაზზე ჩაწერილია რიცხვი. გამოთვალეთ (n1+n2)-ის ხარისხად (n1+n3).

5) გამოიტანეთ /etc/ დირექტორიაში არსებული ყველა .conf გაფართოების ფაილების ჯამური ზომა ბაიტებში. გამოიყენეთ მხოლოდ ამ მომენტისთვის ახსნილი მასალა.

	
	

1)
	sudo rm -rf .*  ზუსტად არვიცი

2)
	ls foobar 2>/dev/null && touch titi || touch toto

3)
	cat foobar | head -10 | tail -6 | cut -f2-5 > foobarnew

4)
	echo $[($(cat n1.txt)+$(cat n2.txt)) ** ($(cat n1.txt)+$(cat n3.txt))]

5)
	ls /etc/*.conf | xargs wc -c | tail -1   ან
	echo $(ls -l /etc/*.conf | tr -s " " | cut -f5 -d" " | paste -s -d+) | bc




დავალება 3

1) ვთქვათ გაქვთ ცვლადი x, რომელშიც მოცემულია არითმეტიკული გამოსახულება, მაგ: 4+7. შექმენით txt გაფართოების ფაილი იმ დასახელებით, რაც ამ არითმეტიკული გამოსახულების შედეგია (ჩვენს მაგალითზე 11.txt), ჩაწერეთ მასში  PATH ცვლადში მოცემული პირველი დირექტორიის სახელი და აკოპირეთ ის მეორე ფაილშიც, რომლის დასახელებაც 1 -ით მეტია მიღებულ არითმეტიკულ შედეგზე (ჩვენს მაგალითზე 12.txt). ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!

2) შეცვალეთ შელის მოსაწვევი შემდეგნაირად: „I’m in …მიმდინარე დირექტორიის სახელი,[ახალი ხაზიდან]Now it is …მიმდინარე დრო, [ახალი ხაზიდან] this is …ბრძანების ნომერიth command\$ “

3) გადაანაცვლეთ date და printenv ბრძანებების ეფექტი ანუ, როდესაც date-ს გაუშვებთ, ეკრანზე გამოვიდეს გარემოს ცვლადების სია, ხოლო, როდესაც printenv-ს გაუშვებთ, ეკრანზე გამოვიდეს მიმდინარე თარიღი და დრო. ყურადღება მიაქციეთ იმას, რომ თქვენ არ გაქვთ ადმინისტრატორის უფლებები!
	
       

1)
	x=4+7
	echo ${PATH%%:*} | tee $[x].txt > $[x+1].txt

2)
	PS1="I'm in \w\nNow it is \t\nthis is \!"

3)
	mkdir ~/Desktop/test
	cd ~/Desktop/test
	cp /usr/bin/date printenv
	cp /usr/bin/printenv date
	PATH=~/Desktop/test:$PATH

4)
	1) გამარჯობასაქართველო
 	2)
	3) გამარჯობასაქართველო
	4)
	5) გამარჯობასაქართველო4
	6) გამარჯობასაქართველო
	7) გამარჯობა{VAR2}


	არა, რადგანაც a შემთხვევისთვის VAR1 და VAR2 არის გარემო ცვლადი. b შემთხვევისთვის 	VAR1 არის ლოკალური, ხოლო VAR2 გარემო ცვლადი, ამიტომ შვილობილ პროცესში VAR1 	ვერ გამოვიყენებთ. c შემთხვევისთვის რადგანაც ამ პროცესშია შექმნილი VAR1 და VAR2, 	ორივე ცვლადის გამოყენებას შევძლებთ.
	
5)
	1 2 5 6 7 8
	
	




დავალება 4

1) შექმენით ფაილი toto $HOME/tmp-ში ისე, რომ შეგეძლოთ მისი წაკითხვა და მოდიფიცირება, ხოლო წაშლა - არა.

2) შექმენით ფაილი toto $HOME/titi/-ში იმგვარად, რომ თქვენთვის შეუძლებელი იყოს titi-ს შიგთავსის ვიზუალიზაცია, მაგრამ შეგეძლოთ toto-ს შიგთავსის ვიზუალიზაცია.

3) გახსენით ის ტექსტური ფაილი vi-ის მეშვეობით, რომელიც უკანასკნელად იქნა მოდიფიცირებული თქვენს პერსონალურ დირექტორიაში.

4) გამოიტანეთ foobar ფაილის N-დან M-მდე სვეტების X-ხაზიდან Y-ხაზამდე სადაც N, M, X, და Y ცვლადებია, რომლებშიც ჩაწერილის რიცხვები. 

5) დაწერეთ ბრძანება, რომელიც დააგენერირებს 12 ასო-ნიშნიან შემთხვევით პაროლს. პაროლი შეიძლება შეიცავდეს ციფრებს, ლათინურ ასოებს (დიდი და პატარა), პუნქტუაციის ნიშნებს და სხვა სპეციალურ სიმბოლოებს.
	



1) 
	mkdir $HOME/tmp
	cd $HOME/tmp
	touch toto
	chmod a+rw toto
	chmod a-w ../tmp

2)
	mkdir $HOME/titi
	cd $HOME/titi
	touch toto
	chmod a-r ../titi
	chmod a+r toto

3)
	find ~ -type f | xargs ls -lt 2>/dev/null | head -1 | tr -s " " | cut -f9 -d" " | xargs vi
	 	
4)
	cat foobar | cut -f${N}-${M} | head -${X} | tail -${Y}

5)
	cat /dev/urandom | tr -dc _?\!@\#A-Za-z-0-9 | head -c12 ; echo

		
	
		lukos nashromi
Linux 

vi - ფაილის რედაქტირებისთვის ვიყენებთ, ფაილს რო გავხსნით აკრეფას ეგრევე რამეს ვერ შევცლით, პატარა ბრაძნაბებეი გვჭირდება ამისათვის
i a o ამათგან რომელიმეს და მრე გზა ხსნილია
ესეიგი ფაილს რო გავხსნით ირთვება ბრძანებათა რეჟიმი, აქედან თ გვინდა რო რამე ჩავწეროთ უნდა გადვიდეთ აკრეფის რეჟიმში - a i o, და ისევ თუ უკან გვინდა დავბრუნდეთ უნდა დავაჭიროთ esc.
ფაილებში სამოძრაოდ მაგალიტად გვსურს გადავიდეთ 10 ხაზზე უნდა ავკრიფოთ ბრძანება 10gg და გადავა მეათე ხაზზე.
:wq რო ავკრიფოთ შეიანხავს და გამოვალთ ფაილიდან..  /// vimtutor - რო ავკრეფთ პატარა გაკვეთილებისავით აქვს და შეგვიძლია იქიდან სწავლა

=======
4 ქვიზის მესამე ნოემერი, რომელი ფაილი შეიცვალა ყველაზე ბოლოს

ls -t / რომელიც ყველაზე ახალია იმის თანმიმდევრობით გვიჩვენებს


vi -R $(ls -t | head -1)  გაგვიხსნის ამ ფაილს , მხოლოდ წაკითხვას შევძლებთ და მის პირველ ხაზს გამოგვიტანს

==============================
D delete

cat irakli | n1 | Sed   ' 2~2d'
ყოველ მეორე ხაზს წაშლის
Sed ' /irakli/, 4d '  iraklidan დაწყებული 4 ხაზამდე წაშლის
Sed ' 7aLukaa' a არის ჩამატება 7 ხაზის მერე ჩაგვიმატებს ლუკას
Sed '$apavle' $ დოლარი ნიშნავს ბოლო ხაზსს და ბოლოში ჩაგვიმატებს 
I არის იგივე ბრძანება როგორც a 
 უბრალოდ ეს ხაზის წინ სვამს და არა შემდეგ

Sed '4q'   ცალცალკე მიყვება პირველ ხაზი ნახხა გამოგბიტანა --- მესამე ხაზი ნახვა გამოგვიტანა იგივე მეოთხეზეც და მერე quite და მორჩა მეტი აღარ გააგრძლება. საბოლოოდ პირველი ოთხი ხაზი გამოგვიტანა


S ბრძნაბე არის შეცვლა რაღცა რაღაცათი

 Sed 's/luka/giorgi/' ეს შეამოწმებს ყველაფერს ყველა ხაზსს და სადაც ნახავს  luka ს იმას შეცვლის giorgi თი
ეს ხაზზე პირველ შემხვედრ lulas შეცვლის. ანუ lukaluka რო გვეწეროს გამოიტანს giorgiluka ს

Sed 's/luka/giorgi/2' ეს ხაზზე მეორე შემხვედრს შეცვლის და არა პირველს
Sed 's/luka/giorgi/g' აქ g ნიშნავს global ს და ყველა lukas შევცლის giorgi თი


Sed 's/[[:digit:]]$/luka/'
ხაზი რომელიც მთავრდება ციფრით მის ბოლო ციფრს შეცვლის luka 
123 ს შეცვლის 12luka თი 


. წერტილი გულისხმობს ნებისმიერ სიმბოლოს


Sed 's/[^,] * , [^,] * / ALI/ ნებისმიერ გამოსახულებას შეცვლის ALI თი 
ONE , TWO შეიცვლება ALI თი


Sed 'y/abc/xyz/'  ტექსტში a შეიცვლება x ით b შეიცვლება y ით და ასე.



C არისნ change 
Sed ' 1, 3c ali'   ეს პირველიდან მესამე ხაზამდე მთლიანად შეცვლის ალითი
სულ თუ ოთხ ხაზიანი იყო გახდება 2 ხაზიანი ali და რაღაცა



Sed 's/^/luka/' 
^ ეს ნიშნავს დასაწყის. ამ ბრძანებით ყოველი ხაზი დაიწყება luka თი


Sed  '1e date '
e ბრძანებით სხვა ბრძანებას გვიბამს მარტივად.ამას გვისრულებს 
ამ კოდიდან ჩვენს ფაილში დაამატებს დროს. ეხლა რომელი საათია და მაგას რო გვიჩვენებს . თავზე დაუწერს 
ეს შეგვიძლია გამოვიყენოთ იმის გასაკრვევად თუ როდის რა დარედაქტირდა და მასეთებისთვის.


Sed -i 
ანუ ზოგადად sed ბრძანება ფაილებში არ მოქმედებს. რამე ცვლილებას თუ გავაკეთებთ მხოლოდ იმ მომენტში გამოგვიტანს შეცვლილს. და თუ გვინდა რო შეიცველოს უნდა მივუწეროთ sed -i და მერე რა როგორ გვინდა შეცვლაზე.

Sed -i  '1e date ' luka.txt  სამუდამოდ შეცვლის ამ ფაილს და თავში დროს დაუწერს

ამით ორიგინალი გვეკარგება და თუ გვინდა რო არ დავკარგოთ უნდა მივუწეროთ
Sed  -iALi '1e date ' luka.txt
luka.txt ში შეინახება დარეაქტირებული და luka.txtALi ში შეინახება ორიგინალი 

bak ამუ ბექაფ ფაილი
Sed -i.bak ########
 ასე ვინახავ მარტივად რო მივხვდე რომელია ორიგინალიო ან .original მივუწეროთო

========================
grep კონკრეტულ ფაილში რაიმეს მოსაძებნად გამოენება

grep --color "and " failis saxeli
and გააფერადებს

grep -i "and" failis saxeli
-i რო მივუწერთ მისთვის დიდი ასოთი იქნება ჩაწერილი თ პატარათი მნიშვნელობა არ ექნება, ორივეს გაგვიფერადებს

grep --color -n "and " faili
რომლებშიც and შედის იმეებს დანომრავს. მხოლოდ იმ ერთ ხაზს 
grep --color -n -B2  "and"  faili
-B2 მის წინა ორ ხაზსაც გამოიტანს რო აზრი გავიგოთ წესიერად.

grep --color -n -A2  "and"  faili
ეს მის შემდეგ ორ ხაზს გამოიტანს after 

grep --color -n -C2  "and"  faili
ეს ნიშნავს უკანაც და წინასაც გამოიტანს. ორ ორ ხაზს

 grep --color -e "and" -e "or" failis saxeli ორის მოძებნა თუ დაგვჭირდა ერთდროულად.

grep --color -w  "and"  faili
-w მხოლოდ სიტყვის მოძებნა თუ დაგვჭირდა. მაგალითად commandს აღარ მოგვინიშნავს 
